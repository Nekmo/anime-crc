#!/usr/bin/env python3
"""
CRC32 generator and checker. 
2017-13-08 v0.5-dev

Based on crc script version 0.2 (2009.01.25) by:
Copyright (c) 2009, Taoufik El Aoumari

Modified by nekmo and ntrrgc to add several features:

- Add CRC32 codes to files
- More Pythonic code
- Fix size == 0 bug
- Logging
- Console arguments
- Compute CRC32 on files missing it without renaming them
- Customizable logging level
- Ported to Python3
- Recursive exploration
- Locale-aware sorting in recursive exploration
- Cleared progress output on exit
- Add option to remove CRC tags
- Add option to warn of missing tags

Released under the GPL license http://www.gnu.org/licenses/gpl-3.0.txt
"""

import locale
import logging
import os
import re
import sys
import zlib
from typing import Union, Tuple, List

locale.setlocale(locale.LC_ALL, "")


def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'

    class K:
        def __init__(self, obj, *args):
            self.obj = obj

        def __lt__(self, other):
            return mycmp(self.obj, other.obj) < 0

        def __gt__(self, other):
            return mycmp(self.obj, other.obj) > 0

        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0

        def __le__(self, other):
            return mycmp(self.obj, other.obj) <= 0

        def __ge__(self, other):
            return mycmp(self.obj, other.obj) >= 0

        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0

    return K


import argparse

# Colors
c_null = "\x1b[00;00m"
c_red = "\x1b[31;01m"
c_green = "\x1b[32;01m"
seq_backspace = "\x08" * 8
clear_progress = seq_backspace + " " * 8 + seq_backspace

long_extensions = {".tar.gz", ".tar.bz", ".tar.xz"}


def split_file_extension(file_name: str) -> Tuple[str, str]:
    """
    Split the given file name as (base_name, extension).
    The extension either starts by dot or is empty string.
    """
    long_extension = next((
        ext
        for ext in long_extensions
        if file_name.endswith(ext)), None)
    if long_extension:
        base_name = file_name.rsplit(long_extension, 1)[0]
        return base_name, long_extension

    split_name = file_name.rsplit(".", 1)
    if len(split_name) == 1:
        # Handle dot-less files like "Makefile"
        return split_name[0], ""
    elif len(split_name) == 2 and split_name[0] == "":
        # Handle hidden files that start with dot, like ".directory".
        # We don't consider ".directory" an extension, but rather the base name.
        return split_name[1], ""
    else:
        # Handle normal extensions, like in "hello.txt"
        return split_name[0], "." + split_name[1]


class CRCStorageInterface(object):
    @property
    def name(self):
        raise NotImplementedError

    def get_declared_crc(self, file_name: str) -> Union[str, None]:
        """@:return String or None, if not found."""
        raise NotImplementedError

    def set_declared_crc(self, file_name: str, hex_uppercase_crc: str) -> None:
        raise NotImplementedError

    def unset_declared_crc(self, file_name: str) -> bool:
        raise NotImplementedError

    def get_file_repr(self, file_name: str, match_color: str,
                      declared_hex_uppercase_crc: str) -> str:
        """Representation of the file name printed to the log."""
        raise NotImplementedError


class ChainCRCStorage:
    def __init__(self, stores: List[CRCStorageInterface]):
        self.stores = stores

    # Should return this, but PyCharm is not smart enough to handle it:
    # Union[Tuple[str, CRCStorageInterface], Tuple[None, None]]:
    def get_declared_crc_and_store(self, file_name: str) -> Tuple[
        Union[str, None], Union[CRCStorageInterface, None]]:
        for store in self.stores:
            crc = store.get_declared_crc(file_name)
            if crc:
                return crc, store
        return None, None

    def set_declared_crc(self, file_name: str, hex_uppercase_crc: str) -> None:
        for store in self.stores:
            store.set_declared_crc(file_name, hex_uppercase_crc)

    def unset_declared_crc(self, file_name: str) -> bool:
        removed_anything = False
        for store in self.stores:
            removed_this = store.unset_declared_crc(file_name)
            removed_anything = removed_anything or removed_this
        return removed_anything


class FileNameCRCStorage(CRCStorageInterface):
    name = 'filename'

    def get_file_repr(self, file_name: str, match_color: str,
                      declared_hex_uppercase_crc: str) -> str:
        before_crc, crc_portion, after_crc = re.match(
            r"^(.*\[)([a-fA-F0-9]{8})(\].*)$", file_name).groups()
        return "{before_crc}{match_color}{crc_portion}{c_null}{after_crc}".format(
            c_null=c_null, **locals())

    def get_declared_crc(self, file_name: str) -> Union[str, None]:
        match = re.match(r".*\[([a-fA-F0-9]{8})\].*", file_name)
        if match:
            return match.groups()[0].upper()

    def set_declared_crc(self, file_name: str, hex_uppercase_crc: str) -> None:
        directory = os.path.dirname(file_name)
        base_name = os.path.basename(file_name)

        name_part, extension = split_file_extension(
            self._name_without_crc(base_name))

        name_part_with_path = os.path.join(directory, name_part)
        name_pattern = '{name_part_with_path} [{hex_uppercase_crc}]{extension}'
        new_file_name = name_pattern.format(**locals())

        self._do_rename(file_name, new_file_name)

    @staticmethod
    def _name_without_crc(file_name: str) -> str:
        return re.sub(r" ?\[([a-fA-F0-9]{8})\]", "", file_name)

    @staticmethod
    def _do_rename(file_name: str, new_file_name: str) -> None:
        logging.info('%s -> %s' % (file_name, new_file_name))
        os.rename(file_name, new_file_name)

    def unset_declared_crc(self, file_name: str) -> bool:
        new_file_name = self._name_without_crc(file_name)
        if file_name != new_file_name:
            self._do_rename(file_name, new_file_name)
            return True
        else:
            return False


try:
    import xattr

    python_xattr_available = True
except ImportError:
    python_xattr_available = False


class XAttrCRCStorage(CRCStorageInterface):
    name = "xattr"

    def get_declared_crc(self, file_name: str) -> Union[str, None]:
        try:
            return xattr.getxattr(file_name, b"user.nekcrc").decode()
        except OSError:
            return None

    def set_declared_crc(self, file_name: str, hex_uppercase_crc: str) -> None:
        logging.info('%s (%s)' % (file_name, hex_uppercase_crc))
        xattr.setxattr(file_name, b"user.nekcrc", hex_uppercase_crc.encode())

    def unset_declared_crc(self, file_name: str) -> bool:
        try:
            xattr.removexattr(file_name, b"user.nekcrc")
            logging.info('%s (removed CRC xattr)' % file_name)
            return True
        except OSError:
            return False

    def get_file_repr(self, file_name: str, match_color: str,
                      declared_hex_uppercase_crc: str) -> str:
        return f"{file_name} ({match_color}{declared_hex_uppercase_crc}{c_null})"


def compute_crc(filename):
    """Calculate the CRC32 checksum of a file.
    Returns the CRC32 code as an hexadecimal string."""

    crc = 0
    file = open(filename, "rb")
    buff_size = 65536
    size = os.path.getsize(filename)
    done = 0

    if not size:
        # Empty file, quit
        logging.error('The file %s is empty' % filename)
        return
    try:
        while True:
            # While there is some data remaining...
            data = file.read(buff_size)
            done += buff_size
            # ... show our progress
            sys.stdout.write("%7d" % (done * 100 / size) + "%" + seq_backspace)
            if not data:
                # No more data, quit
                break
            crc = zlib.crc32(data, crc)
    except KeyboardInterrupt:
        # ^C was pressed in the terminal, reset the terminal and exit the
        # program
        sys.stdout.write(seq_backspace)
        file.close()
        sys.exit(1)

    file.close()

    return "%.8X" % crc


def check_files(files):
    """Check CRC32 for the provided file name list."""
    for file_name in files:
        try:
            # Find CRC32 within the file name
            declared_crc, store = read_crc_storage.get_declared_crc_and_store(
                file_name)
            if declared_crc is None:
                level = "warning" if warn_no_crc else "info"
                getattr(logging, level)(
                    '%s does not have a CRC tag' % file_name)
                continue

            # Calculate CRC32
            computed_crc = compute_crc(file_name)
            if not computed_crc:
                continue  # empty file

            # Check the computed CRC32 matches the declared CRC32
            if computed_crc == declared_crc:
                match_color = c_green
                level = 'info'
            else:
                match_color = c_red
                level = 'warning'

            formatted_name = store.get_file_repr(file_name, match_color,
                                                 declared_crc)
            getattr(logging, level)("{match_color}{computed_crc}{c_null}  "
                                    "{formatted_name}".format(c_null=c_null,
                                                              **locals()))
        except IOError as e:
            logging.error(e)
            continue


def add_crc32_tags(files):
    """Add a CRC32 code to files missing it."""
    for file_name in files:
        try:
            # Try to read existing CRC32
            declared_crc, store = read_crc_storage.get_declared_crc_and_store(
                file_name)
            if declared_crc:
                store_name = store.name
                logging.debug(
                    f"{file_name} already has a CRC declared with '{store_name}' store.")
                continue

            computed_crc = compute_crc(file_name)
            if not computed_crc:
                continue

            write_crc_storage.set_declared_crc(file_name, computed_crc)

        except IOError as e:
            print(e)
            continue


def delete_crc32_tags(files):
    """Remove CRC32 codes to the specified files (danger!)"""
    for file_name in files:
        try:
            removed_anything = write_crc_storage.unset_declared_crc(file_name)
            if not removed_anything:
                logging.info("%s has no CRC tags to remove." % file_name)

        except IOError as e:
            print(e)
            continue


def separate_directories(file_list):
    directories = []
    files = []

    for file_name in file_list:
        if os.path.isdir(file_name):
            directories.append(file_name)
        else:
            files.append(file_name)

    return files, directories


def recurse_file_list(original_list):
    original_files, original_dirs = separate_directories(original_list)

    if not recurse_files:
        return original_files  # filter out directories

    found_files = []
    for rootdir in original_dirs:
        for root, subFolders, files in os.walk(rootdir):
            files.sort(key=cmp_to_key(locale.strcoll))
            subFolders.sort(key=cmp_to_key(locale.strcoll))
            for file in files:
                f = os.path.join(root, file)
                found_files.append(f)

    return original_files + found_files


def parse_store_list(string_list: str) -> List[CRCStorageInterface]:
    stores = {
        "filename": FileNameCRCStorage,
        "xattr": XAttrCRCStorage,
    }

    ret = []
    for store_name in string_list.split(","):
        if store_name == "xattr" and not python_xattr_available:
            logging.info("Cannot use xattr store without python3-xattr.")
            raise SystemExit(2)

        ret.append(stores[store_name]())
    return ret


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='CRC32 generator and checker.',
                                     formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    # addcrc32
    parser.add_argument('-a', '--addcrc32', dest='add_crc32_tags', nargs='+',
                        help='Generate CRC32 for files and rename them.')

    parser.add_argument('--delete', dest='delete_crc32_tags', nargs='+',
                        help='Delete CRC32 tags in the specified files.')

    # Recursive
    parser.add_argument('-r', dest='recursive', action='store_const',
                        const=True, default=False,
                        help='Explore directories recursively.')
    # log level
    parser.add_argument('--debug', dest='level', action='store_const',
                        const=logging.DEBUG, default=logging.INFO,
                        help='Set log level to debugging messages.')
    parser.add_argument('--warning', dest='level', action='store_const',
                        const=logging.WARNING, default=logging.INFO,
                        help='Set log level to warnings (hides successful files).')

    parser.add_argument('--no-warn-missing-xattr-ext', action='store_const',
                        const=True, default=False,
                        help="Don't warn of missing python3-xattr optional dependency.")

    parser.add_argument('--warn-no-crc', action='store_const',
                        const=True, default=False,
                        help="Show a warning if no CRC tags are found in a file.")

    # Stores
    parser.add_argument('--read-from', type=parse_store_list,
                        default="filename,xattr" if python_xattr_available else "filename",
                        help="A comma-separated list of tag stores used for checking integrity. "
                             "First successful read is used.")

    parser.add_argument('--write-to', type=parse_store_list,
                        default="filename",
                        help="A comma-separated list of tag stores used for writing CRC tags. "
                             "Tags are written in every tag store specified.")

    # check
    parser.add_argument('check', nargs='*',
                        help='Check CRC32 of files.')

    args = parser.parse_args()

    # Set log level
    logging.basicConfig(level=args.level, format='%(levelname)-8s %(message)s')

    if not python_xattr_available and not args.no_warn_missing_xattr_ext:
        logging.warning(
            "python3-xattr is not installed, no 'xattr' store support.")

    recurse_files = args.recursive

    warn_no_crc = args.warn_no_crc

    read_crc_storage = ChainCRCStorage(args.read_from)
    write_crc_storage = ChainCRCStorage(args.write_to)
    if python_xattr_available:
        read_crc_storage.stores.append(XAttrCRCStorage())

    if args.add_crc32_tags:
        # Add CRC32 to files
        add_crc32_tags(recurse_file_list(args.add_crc32_tags))

    if args.delete_crc32_tags:
        # Remove CRC32 tags
        delete_crc32_tags(recurse_file_list(args.delete_crc32_tags))

    if args.check:
        # Check files integrity against existing CRC32 tags
        check_files(recurse_file_list(args.check))

    sys.stdout.write(clear_progress)

    if not args.check and not args.add_crc32_tags and not args.delete_crc32_tags:
        parser.print_help()
        raise SystemExit(2)
