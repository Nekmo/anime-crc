#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Version 0.2 2009.01.25
# Copyright (c) 2009, Taoufik El Aoumari
# Released under the GPL license http://www.gnu.org/licenses/gpl-3.0.txt

"""
    ESTE PROGRAMA HA SIDO _REEDITADO POR
    
             -- NEKMO.COM --
        email: contacto@nekmo.com
        
     La licencia de este programa es:
              - GPL 3.0 -
         Versión del programa:
          # 01/05/2011 (0.4)
         
    Feature añadida a programa original:
      - Dar CRC32 a archivos
      - Pythonización
      - Corrección bug size == 0
      - Uso de logs
      - Uso de argumentos en consola
      - CRC32 de archivos sin renombrarlos
      - Establecer nivel del logging
      - Compatible cpn Python 2.x y 3.x
      - Recursividad
                                     """

# Módulos requeridos
import sys, re, zlib, os
import logging

try:
    import argparse
except ImportError:
    logging.error('Necesita el módulo argparse.')
    sys.exit(0)



#Colores
c_null  = "\x1b[00;00m"
c_red   = "\x1b[31;01m"
c_green = "\x1b[32;01m"
p_reset = "\x08"*8
 
# modelo de nuevos archivos
base = '%s [%s]'

def crc32_checksum(filename):
    """Generador del CRC del archivo
       filename: string
                 Ruta al archivo"""
    
    # Variables para comprobación
    crc = 0
    file = open(filename, "rb")
    buff_size = 65536
    size = os.path.getsize(filename)
    done = 0
    
    if not size:
        # El archivo no tiene tamaño, salir
        logging.error('El archivo %s no tiene datos' % filename)
        return
    try:
        while True:
            # Mientras haya datos...
            data = file.read(buff_size)
            done += buff_size
            # informar de situación actual de conteo
            sys.stdout.write("%7d"%(done*100/size) + "%" + p_reset)
            if not data:
                # Ya no hay más datos, salir
                break
            crc = zlib.crc32(data, crc)
    except KeyboardInterrupt:
        # Detectada excepción de interrupción por teclado
        sys.stdout.write(p_reset)
        # Cerrar el archivo
        file.close()
        sys.exit(1) 
    sys.stdout.write("")
    # !!!Cerrar el archivo
    file.close()
    # Cálculo
    if crc < 0:
        crc &= 2**32-1
    return "%.8X" %(crc)

def check(files):
    """Comprobador del CRC del archivo
       files: tuple or list
              listado de nombres de archivos"""
    for file in files:
        try:
            # Encontrar CRC32 en el nombre de archivo
            dest_sum = re.split("\[([a-fA-F0-9]{8})\]", file)
            if len(dest_sum) < 2:
                logging.debug('%s no tenía CRC' % file)
                continue
            dest_sum = dest_sum[-2]
            # Generar CRC32
            crc = crc32_checksum(file)
            if not crc:
                continue
            # CRC32 del nombre de archivo == CRC32 generado
            if crc == dest_sum.upper():
                c_in = c_green
                level = 'info'
            else:
                c_in = c_red
                level = 'warning'
            sfile = file.split(dest_sum)
            getattr(logging, level)("%(c_in)s%(crc)s%(c_null)s  "\
                                    "%(sfile0)s%(c_in)s%(dest_sum)s%(c_null)s%(sfile1)s" % \
                                    {'c_in': c_in, 'c_null': c_null, 'sfile0': sfile[0],
                                     'sfile1': sfile[1], 'dest_sum': dest_sum, 'crc': crc})
        except(IndexError, ValueError):
            logging.error(crc + "   " + file)
        except IOError as e:
            logging.error(e)
            continue

def addcrc32(files):
    """Generador del CRC del archivo
       files: tuple or list
              listado de nombres de archivos"""    
    for file in files:
        try:
            # Generar CRC32
            crc = crc32_checksum(file)
            if not crc:
                return
            # Si hay un punto... (extensión)
            if '.' in file:
                # hay un punto (por tanto extensión)
                file_split = file.split('.')
                ext = '.' + file_split[-1]
                new_file = base  % ('.'.join(file_split[0:-1]), crc)
            else:
                # no hay extensión
                ext = ''
                new_file = base  % (file, crc)
            # Informar del cambio de nombre de archivo
            logging.info('%s -> %s' % (file, new_file + ext))
            # Renombrar archivo
            os.rename(file, new_file + ext)
        except(IndexError, ValueError):
            print(crc+"   "+file)
        except IOError as e:
            print(e)
            continue

if __name__ == '__main__':    
    # Description
    parser = argparse.ArgumentParser(description=
                                    'Generador y comprobador de CRC32\'s')
    # addcrc32
    parser.add_argument('-a', '--addcrc32', dest='addcrc32', nargs='+',
                        help='Generar CRC32\'s de archivos y cambiar los nombres con ellos.')
    # Recursive
    parser.add_argument('-r', dest='recursive', action='store_const',
                        const=True, default=False,
                        help='Analizar directorios recursivamente.')
    # level logs
    parser.add_argument('--debug', dest='level', action='store_const',
                        const=logging.DEBUG, default=logging.INFO,
                        help='Establecer el nivel de los logs a debug.')
    parser.add_argument('--warning', dest='level', action='store_const',
                        const=logging.WARNING, default=logging.INFO,
                        help='Establecer el nivel de los logs a solo advertencias.')
    parser.add_argument('--error', dest='level', action='store_const',
                        const=logging.ERROR, default=logging.INFO,
                        help='Establecer el nivel a solo errores del programa.')
    # check
    parser.add_argument('check', nargs='*',
            help='Comprobar el CRC32 de los archivos.')
    args = parser.parse_args()

    # Recursive
    if args.recursive:
        file_list = []
        for rootdir in args.check:
            for root, subFolders, files in os.walk(rootdir):
                for file in files:
                    f = os.path.join(root, file)
                    file_list.append(f)
        args.check.extend(file_list)
    # Propiedades de los logs
    logging.basicConfig(level=args.level, format='%(levelname)-8s %(message)s')
    
    if args.addcrc32:
        # Generar CRC32 de los archivos
        addcrc32(args.addcrc32)
    elif not args.check:
        print('No se han establecido argumentos.')
    else:
        # Comprobar los CRC32 de los archivos
        check(args.check)